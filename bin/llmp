#!/usr/bin/env python3

"""Render prompt templates with basic variable substitution."""

import argparse
import os
import re
import subprocess
import sys
from pathlib import Path


VAR_PATTERN = re.compile(r"\{\{([A-Za-z0-9_-]+)\}\}")
FREE_VAR_PATTERN = re.compile(r"\[\[([A-Za-z0-9_-]+)\]\]")


class PromptError(Exception):
    """Raised when prompt rendering fails due to invalid input or missing data."""


def strip_quotes(value: str) -> str:
    """Remove one layer of YAML-style quotes from a scalar.

    This is intentionally conservative and only supports basic quoting.

    >>> strip_quotes('"hello"')
    'hello'
    >>> strip_quotes("'hello'")
    'hello'
    >>> strip_quotes("plain")
    'plain'
    """
    if len(value) >= 2 and value[0] == value[-1] and value[0] in ("'", '"'):
        quote = value[0]
        inner = value[1:-1]
        if quote == '"':
            return (
                inner.replace(r"\\", "\\")
                .replace(r"\n", "\n")
                .replace(r"\t", "\t")
                .replace(r"\"", '"')
            )
        return inner.replace("''", "'")
    return value


def parse_yaml_mapping(lines, source_label: str):
    """Parse a minimal YAML mapping into a nested dict.

    Errors include file context and line numbers for easier debugging.
    """
    data = {}
    stack = [(0, data)]

    for idx, raw in enumerate(lines, start=1):
        line = raw.split("#", 1)[0].rstrip("\n")
        if not line.strip():
            continue
        indent = len(line) - len(line.lstrip(" "))
        key_value = line.strip()
        if ":" not in key_value:
            raise PromptError(
                f"Invalid YAML line at {source_label}:{idx}: {raw.rstrip()}"
            )
        key, value = key_value.split(":", 1)
        key = key.strip()
        value = value.strip()

        while stack and indent < stack[-1][0]:
            stack.pop()
        if not stack:
            raise PromptError(
                f"Invalid indentation at {source_label}:{idx}: {raw.rstrip()}"
            )

        target = stack[-1][1]
        if value == "":
            target[key] = {}
            stack.append((indent + 2, target[key]))
        else:
            target[key] = strip_quotes(value)

    return data


def load_strings_map(path: Path) -> dict[str, str]:
    """Load top-level string mappings from llm/strings.yml if present."""
    if not path.exists():
        return {}
    content = path.read_text(encoding="utf-8")
    data = parse_yaml_mapping(content.splitlines(), str(path))

    strings: dict[str, str] = {}
    for key, value in data.items():
        if isinstance(value, str):
            strings[key] = value
    return strings


def run_command(cmd: str) -> str:
    """Execute a shell command and return stdout without the final newline."""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if result.returncode != 0:
        raise PromptError(f"Command failed: {cmd}\n{result.stderr.strip()}")
    return result.stdout.rstrip("\n")


def parse_kv(arg: str) -> tuple[str, str]:
    """Parse a KEY:VALUE pair.

    >>> parse_kv("name:value")
    ('name', 'value')
    """
    if ":" not in arg:
        raise PromptError(f"Invalid key/value: {arg}")
    key, value = arg.split(":", 1)
    key = key.strip()
    if not key:
        raise PromptError(f"Invalid key/value: {arg}")
    return key, value


def load_file_value(path: str) -> str:
    """Read a UTF-8 file and return its contents."""
    file_path = Path(path)
    if not file_path.exists():
        raise PromptError(f"File not found: {path}")
    return file_path.read_text(encoding="utf-8")


def list_free_vars(text: str) -> list[str]:
    """Return unique free variables found in a prompt template.

    >>> list_free_vars("[[a]] and [[b]] and [[a]]")
    ['a', 'b']
    """
    return sorted(set(FREE_VAR_PATTERN.findall(text)))


def list_templates(llm_root: Path) -> list[str]:
    """List prompt templates under llm_root/prompt, without .md suffix."""
    prompt_root = llm_root / "prompt"
    if not prompt_root.exists():
        return []
    templates = []
    for path in prompt_root.rglob("*.md"):
        rel_path = path.relative_to(prompt_root).as_posix()
        templates.append(rel_path[:-3])
    return sorted(templates)


def list_strings(strings_path: Path) -> list[str]:
    """List defined string keys in llm/strings.yml."""
    strings = load_strings_map(strings_path)
    return sorted(strings.keys())


def list_string_items(strings_path: Path, expand: bool) -> list[tuple[str, str]]:
    """Return (key, value) items, optionally expanding ${ENV} and $()."""
    strings = load_strings_map(strings_path)
    items = []
    for key in sorted(strings.keys()):
        value = strings[key]
        items.append((key, expand_value(value) if expand else value))
    return items


def expand_value(value: str) -> str:
    """Expand $(command) and ${ENV} in a string value.

    A literal "$" can be escaped as "\\$".

    >>> expand_value("X:\\\\$Y")
    'X:$Y'
    """
    result = []
    i = 0
    while i < len(value):
        char = value[i]
        if char == "\\" and i + 1 < len(value) and value[i + 1] == "$":
            result.append("$")
            i += 2
            continue
        if char == "$" and i + 1 < len(value):
            next_char = value[i + 1]
            if next_char == "{":
                end = value.find("}", i + 2)
                if end == -1:
                    raise PromptError("Unclosed ${} in strings.yml value")
                env_key = value[i + 2:end]
                result.append(os.environ.get(env_key, ""))
                i = end + 1
                continue
            if next_char == "(":
                end = value.find(")", i + 2)
                if end == -1:
                    raise PromptError("Unclosed $() in strings.yml value")
                cmd = value[i + 2:end].strip()
                result.append(run_command(cmd))
                i = end + 1
                continue
        result.append(char)
        i += 1
    return "".join(result)


def substitute_prompt(text: str, strings, free_vars, strict: bool) -> str:
    """Apply {{var}} and [[var]] substitutions to template text."""
    def replace_var(match):
        key = match.group(1)
        if key in strings:
            return expand_value(strings[key])
        raise PromptError(f"Missing mapping for variable: {key}")

    def replace_free(match):
        key = match.group(1)
        if key in free_vars:
            return free_vars[key]
        if strict:
            raise PromptError(f"Missing free variable: {key}")
        return match.group(0)

    text = VAR_PATTERN.sub(replace_var, text)
    text = FREE_VAR_PATTERN.sub(replace_free, text)
    return text


def repo_root() -> Path:
    """Return the repository root based on this script's location."""
    return Path(__file__).resolve().parent.parent


def resolve_prompt_path(base_root: Path, name: str) -> Path:
    """Resolve a prompt file under <root>/prompt, adding .md when missing."""
    prompt_root = base_root / "prompt"
    prompt_path = prompt_root / name
    if prompt_path.suffix == "":
        prompt_path = prompt_path.with_suffix(".md")
    return prompt_path


def read_prompt(path: Path) -> str:
    """Read prompt file contents as UTF-8."""
    if not path.exists():
        raise PromptError(f"Prompt not found: {path}")
    return path.read_text(encoding="utf-8")


def build_free_vars(kv_pairs, file_pairs) -> dict[str, str]:
    """Combine -s and -f inputs into a single mapping."""
    free_vars = {}
    for item in kv_pairs:
        key, value = parse_kv(item)
        free_vars[key] = value
    for item in file_pairs:
        key, path = parse_kv(item)
        free_vars[key] = load_file_value(path)
    return free_vars


def render_prompt(
    prompt_text: str,
    strings_path: Path,
    free_vars: dict[str, str],
    strict: bool,
) -> str:
    """Render a prompt with substitutions."""
    strings = load_strings_map(strings_path)
    return substitute_prompt(prompt_text, strings, free_vars, strict)


def run_doctests() -> int:
    """Run doctests for this module."""
    import doctest

    result = doctest.testmod()
    if result.failed:
        return 1
    return 0


def parse_args(argv: list[str]) -> argparse.Namespace:
    """Return parsed CLI arguments."""
    parser = argparse.ArgumentParser(description="Render prompt templates.")
    parser.add_argument(
        "--doctest",
        action="store_true",
        help="Run doctests and exit",
    )
    parser.add_argument(
        "-r",
        "--root",
        help="Override LLM root directory (defaults to <repo>/llm)",
    )

    subparsers = parser.add_subparsers(dest="command")

    render_parser = subparsers.add_parser("render", help="Render a prompt template")
    render_parser.add_argument("name", help="Prompt name or path under llm/prompt")
    render_parser.add_argument(
        "-s",
        action="append",
        default=[],
        metavar="VAR:VALUE",
        help="Substitute [[VAR]] with VALUE",
    )
    render_parser.add_argument(
        "-f",
        action="append",
        default=[],
        metavar="VAR:FILE",
        help="Substitute [[VAR]] with file contents",
    )
    render_parser.add_argument(
        "-S",
        action="store_true",
        help="Strict mode for free variables",
    )

    subparsers.add_parser("list", aliases=["ls"], help="List available templates")

    strings_parser = subparsers.add_parser("strings", help="List defined strings")
    strings_parser.add_argument(
        "-v",
        "--values",
        action="store_true",
        help="Show values only",
    )
    strings_parser.add_argument(
        "-k",
        "--keys",
        action="store_true",
        help="Show keys only",
    )
    strings_parser.add_argument(
        "-e",
        "--expand",
        action="store_true",
        help="Expand ${ENV} and $() in values",
    )

    vars_parser = subparsers.add_parser(
        "vars",
        aliases=["free"],
        help="List free variables in a template",
    )
    vars_parser.add_argument("target", help="Target prompt")

    return parser.parse_args(argv)


def main():
    """CLI entrypoint."""
    argv = sys.argv[1:]
    commands = {"render", "list", "ls", "strings", "vars", "free"}
    if argv and not argv[0].startswith("-") and argv[0] not in commands:
        argv = ["render", *argv]
    args = parse_args(argv)

    if args.doctest:
        return run_doctests()

    repo_path = repo_root()
    llm_root = Path(args.root).expanduser() if args.root else repo_path / "llm"
    strings_path = llm_root / "strings.yml"

    if args.command in ("list", "ls"):
        for template in list_templates(llm_root):
            print(template)
        return 0

    if args.command == "strings":
        items = list_string_items(strings_path, args.expand)
        if args.keys and args.values:
            raise PromptError("Use either --keys or --values, not both")
        if args.keys:
            for key, _ in items:
                print(key)
        elif args.values:
            for _, value in items:
                print(value)
        else:
            for key, value in items:
                print(f"{key}: {value}")
        return 0

    if args.command in ("vars", "free"):
        prompt_path = resolve_prompt_path(llm_root, args.target)
        prompt_text = read_prompt(prompt_path)
        for var in list_free_vars(prompt_text):
            print(var)
        return 0

    if args.command == "render":
        prompt_path = resolve_prompt_path(llm_root, args.name)
        prompt_text = read_prompt(prompt_path)
        free_vars = build_free_vars(args.s, args.f)

        result = render_prompt(prompt_text, strings_path, free_vars, args.S)
        sys.stdout.write(result)
        return 0

    raise PromptError("Missing command")


if __name__ == "__main__":
    try:
        sys.exit(main())
    except PromptError as exc:
        print(f"llmp: {exc}", file=sys.stderr)
        sys.exit(1)
